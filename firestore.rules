rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { 
      return request.auth != null; 
    }
    
    function userId() { 
      return request.auth.uid; 
    }

    // פרופיל משתמש – המשתמש עצמו או בן משפחה שמשתף לפחות משפחה אחת
    match /users/{uid} {
      // פונקציה שבודקת האם שני המשתמשים חברים באותה משפחה
      function sharesFamilyWithTarget() {
        // קודם נבדוק שהמשתמש המטרה קיים ויש לו משפחות
        let targetData = resource.data;
        let targetFamilies = targetData.get('families', []);
        
        // אם למטרה אין משפחות, אין גישה
        // בדוק גם ownedFamilyId ו-activeFamilyId כ-fallback
        let targetOwnedFamily = targetData.get('ownedFamilyId', null);
        let targetActiveFamily = targetData.get('activeFamilyId', null);
        let targetAllFamilies = targetFamilies.size() > 0 ? targetFamilies :
          (targetOwnedFamily != null ? [targetOwnedFamily] :
          (targetActiveFamily != null ? [targetActiveFamily] : []));
        
        // עכשיו נבדוק את המשתמש המבקש
        let requesterDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
        let requesterData = requesterDoc.data;
        let requesterFamilies = requesterData.get('families', []);
        let requesterOwnedFamily = requesterData.get('ownedFamilyId', null);
        let requesterActiveFamily = requesterData.get('activeFamilyId', null);
        let requesterAllFamilies = requesterFamilies.size() > 0 ? requesterFamilies :
          (requesterOwnedFamily != null ? [requesterOwnedFamily] :
          (requesterActiveFamily != null ? [requesterActiveFamily] : []));
        
        // בדוק אם יש משפחה משותפת
        return targetAllFamilies.size() > 0 &&
               requesterAllFamilies.size() > 0 &&
               targetAllFamilies.hasAny(requesterAllFamilies);
      }

      allow read: if isSignedIn() && (uid == userId() || sharesFamilyWithTarget());
      allow write: if isSignedIn() && uid == userId();
    }

    // משפחות
    match /families/{familyId} {
      function isMember() {
        let members = resource.data.get('members', []);
        let ownerId = resource.data.get('ownerId', '');
        return isSignedIn() && (
          userId() in members ||
          ownerId == userId()
        );
      }

      function membersWithinLimit() {
        let nextMembers = request.resource.data.get('members', []);
        return nextMembers.size() <= 2;
      }

      function canJoinByShareCode() {
        let diff = request.resource.data.diff(resource.data);
        let prevMembers = resource.data.get('members', []);
        let nextMembers = request.resource.data.get('members', []);
        return isSignedIn() &&
          resource.data.shareCode != null &&
          request.resource.data.shareCode == resource.data.shareCode &&
          diff.changedKeys().hasOnly(['members', 'updatedAt']) &&
          nextMembers.hasAll(prevMembers) &&
          nextMembers.size() == prevMembers.size() + 1 &&
          nextMembers.hasAny([userId()]) &&
          nextMembers.size() <= 2;
      }

      function canAcceptInviteByEmail() {
        let diff = request.resource.data.diff(resource.data);
        let email = request.auth.token.email;
        let normalizedEmail = email == null ? '' : email.lower();
        let prevEmails = resource.data.get('pendingInviteEmails', []);
        let prevInvites = resource.data.get('pendingInvites', []);
        let nextEmails = request.resource.data.get('pendingInviteEmails', []);
        let nextInvites = request.resource.data.get('pendingInvites', []);
        let prevMembers = resource.data.get('members', []);
        let nextMembers = request.resource.data.get('members', []);
        return isSignedIn() &&
          normalizedEmail != '' &&
          prevEmails.hasAny([normalizedEmail]) &&
          !nextEmails.hasAny([normalizedEmail]) &&
          diff.changedKeys().hasOnly(['members', 'pendingInviteEmails', 'pendingInvites', 'updatedAt']) &&
          nextEmails.size() == prevEmails.size() - 1 &&
          nextInvites.size() == prevInvites.size() - 1 &&
          nextMembers.hasAll(prevMembers) &&
          nextMembers.size() == prevMembers.size() + 1 &&
          nextMembers.hasAny([userId()]) &&
          nextMembers.size() <= 2;
      }
      
      function isMemberForSubcollection() {
        let family = get(/databases/$(database)/documents/families/$(familyId)).data;
        let members = family.get('members', []);
        let ownerId = family.get('ownerId', '');
        return isSignedIn() && (
          userId() in members ||
          ownerId == userId()
        );
      }

      allow create: if isSignedIn();
      allow read: if isSignedIn();
      allow update, delete: if (isMember() && membersWithinLimit()) || canJoinByShareCode() || canAcceptInviteByEmail();

      // הוצאות
      match /expenses/{expId} {
        allow read, create, update, delete: if isMemberForSubcollection();
      }

      // משימות
      match /tasks/{taskId} {
        allow read, create, update, delete: if isMemberForSubcollection();
      }

      // אירועים
      match /calendarEvents/{eventId} {
        allow read, create, update, delete: if isMemberForSubcollection();
      }

      // הודעות צ'אט
      match /messages/{messageId} {
        allow read, create: if isMemberForSubcollection();
        allow update, delete: if false; // מניעת עריכה/מחיקה של הודעות לאחר שליחה
      }

      // הגדרות כלליות (כולל custodySchedule)
      match /settings/{settingId} {
        allow read, create, update, delete: if isMemberForSubcollection();
      }

      // מסמכים
      match /documents/{docId} {
        allow read, write: if isMemberForSubcollection();
      }

      // בקשות החלפה
      match /swapRequests/{reqId} {
        allow read, create, update, delete: if isMemberForSubcollection();
      }

      // אישורי תשלום
      match /paymentReceipts/{receiptId} {
        allow read, create, update, delete: if isMemberForSubcollection();
      }
    }
  }
}
